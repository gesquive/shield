package engine

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"text/template"
	"time"

	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"
)

var Version string

// DefaultMaxImportDepth is the number of import levels to allow by default
// Import depth prevents an infinite loop of imports
const DefaultMaxImportDepth = 100

type RuleSet struct {
	template       *template.Template
	vars           map[string]interface{}
	templatePath   string
	maxImportDepth uint
}

func NewRuleset(templatePath string) (*RuleSet, error) {
	ruleset := new(RuleSet)

	templateBytes, err := ruleset.readTemplateFile(templatePath)
	if err != nil {
		return nil, errors.Wrapf(err, "could not read template file")
	}
	ruleset.templatePath = templatePath
	ruleset.maxImportDepth = DefaultMaxImportDepth

	expandedBytes, err := ruleset.expandImports(templateBytes, 0)

	rulesetBytes, vars, err := ruleset.extractVars(expandedBytes)
	ruleset.vars = vars

	ruleset.template = template.Must(template.New("rules").Funcs(NetFuncs()).Parse(string(rulesetBytes)))

	return ruleset, nil
}

func (r *RuleSet) SetImportDepth(newDepth uint) {
	r.maxImportDepth = newDepth
}

func (r *RuleSet) GenerateRules(appVersion string) ([]byte, error) {
	t := time.Now()
	header := fmt.Sprintf("# Generated by %s on %s\n", appVersion, t.Format("2006/01/02 15:04:05 -700"))

	var msgBuffer bytes.Buffer
	msgBuffer.WriteString(header)
	err := r.template.Execute(&msgBuffer, r.vars)
	if err != nil {
		return nil, errors.Wrapf(err, "template error")
	}

	return msgBuffer.Bytes(), nil
}

func (r *RuleSet) readTemplateFile(templatePath string) ([]byte, error) {
	if _, err := os.Stat(templatePath); os.IsNotExist(err) {
		return nil, errors.Wrapf(err, "open template")
	}

	templateBytes, err := ioutil.ReadFile(templatePath)
	if err != nil {
		return nil, errors.Wrapf(err, "read file")
	}

	return templateBytes, nil
}

func (r *RuleSet) extractVars(ruleset []byte) ([]byte, map[string]interface{}, error) {
	vars := make(map[string]interface{})
	re := regexp.MustCompile("(?smU)\\s*{\\$(.*)\\$}\\s*")
	matches := re.FindAll(ruleset, -1)
	if matches == nil {
		return ruleset, vars, nil
	}

	for _, match := range matches {
		exps := re.FindSubmatch(match)
		if len(exps) < 2 {
			// Then we don't have a submatch for the group
			continue
		}
		ymlVar := bytes.TrimSpace(exps[1])
		parsedVars := make(map[string]interface{})

		err := yaml.Unmarshal(ymlVar, &parsedVars)
		if err != nil {
			return nil, nil, errors.Wrapf(err, "parse rules")
		}
		for k, v := range parsedVars {
			vars[k] = v
		}

	}
	cleanRules := re.ReplaceAll(ruleset, []byte(""))
	return cleanRules, vars, nil

}

func (r *RuleSet) expandImports(ruleset []byte, depth uint) ([]byte, error) {
	re := regexp.MustCompile("(?smU){\\@(.*)\\@}")

	expandedRules := []byte("")
	match := []byte("no match")
	expandedRules = append(expandedRules, ruleset...)
	for len(match) > 0 {
		match = re.Find(expandedRules)
		if len(match) <= 0 {
			continue
		}
		parts := re.FindSubmatch(match)
		if len(parts) < 2 {
			// matched the brackets, but we are missing the file path, remove the import
			expandedRules = bytes.Replace(expandedRules, parts[0], []byte(""), 1)
			continue
		}
		importPath := string(bytes.TrimSpace(parts[1]))

		if depth < r.maxImportDepth {
			importPaths, err := r.getFileList(importPath)
			if err != nil {
				return nil, err
			}
			importRules := []byte{}
			for _, filePath := range importPaths {
				fileBytes, err := ioutil.ReadFile(filePath)
				if err != nil {
					return nil, errors.Wrapf(err, "could not read '%s'", filePath)
				}

				fileRules, err := r.expandImports(fileBytes, depth+1)
				if err != nil {
					return nil, err
				}
				if len(importPaths) > 1 && fileRules[len(fileRules)-1] != '\n' {
					// when importing files in a directory
					//  make sure to put a space between the lines
					importRules = append(importRules, '\n')
				}
				importRules = append(importRules, fileRules...)
			}

			expandedRules = bytes.Replace(expandedRules, parts[0], importRules, 1)

		} else {
			// we are in too deep, remove the import
			expandedRules = bytes.Replace(expandedRules, parts[0], []byte(""), 1)
		}
	}
	return expandedRules, nil
}

func (r RuleSet) getFilePath(importPath string) (string, error) {
	templateDirPath := path.Dir(r.templatePath)
	relativePath := path.Join(templateDirPath, importPath)

	// First try a relative path
	if _, err := os.Stat(relativePath); err == nil {
		return relativePath, nil
	}
	// Second, try the full path
	if _, err := os.Stat(importPath); err == nil {
		return importPath, nil
	}
	return "", errors.Errorf("Could not find import path '%s'", importPath)
}

func (r RuleSet) isDir(filePath string) bool {
	info, err := os.Stat(filePath)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func (r RuleSet) getFileList(importPath string) ([]string, error) {
	filePath, err := r.getFilePath(importPath)
	if err != nil {
		return []string{}, err
	}

	fileListInfo := []string{}
	if info, err := os.Stat(filePath); err == nil && info.IsDir() {
		// then we have a directory, get the file list
		dirList, err := filepath.Glob(path.Join(filePath, "*"))
		if err != nil {
			return []string{}, err
		}
		for _, filePath := range dirList {
			if r.isDir(filePath) {
				continue
			}
			fileListInfo = append(fileListInfo, filePath)
		}
	} else { // assume its a file, already got stats
		fileListInfo = append(fileListInfo, filePath)
	}
	return fileListInfo, nil
}
