package engine

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"text/template"
	"time"

	"github.com/pkg/errors"
)

var Version string

type RuleSet struct {
	template *template.Template
}

func NewRuleset(templatePath string) (*RuleSet, error) {
	rules := new(RuleSet)

	templateBytes, err := rules.readTemplateFile(templatePath)
	if err != nil {
		return nil, errors.Wrapf(err, "could not read template file")
	}

	rules.template = template.Must(template.New("rules").Funcs(NetFuncs()).Parse(string(templateBytes)))

	return rules, nil
}

func (r *RuleSet) GenerateRules(appVersion string, vars []string) ([]byte, error) {
	t := time.Now()
	header := fmt.Sprintf("# Generated by %s on %s\n", appVersion, t.Format("2006/01/02 15:04:05 -700"))

	var msgBuffer bytes.Buffer
	msgBuffer.WriteString(header)
	err := r.template.Execute(&msgBuffer, vars)
	if err != nil {
		return nil, errors.Wrapf(err, "template error")
	}

	return msgBuffer.Bytes(), nil
}

func (r *RuleSet) readTemplateFile(templatePath string) ([]byte, error) {
	if _, err := os.Stat(templatePath); os.IsNotExist(err) {
		return nil, errors.Wrapf(err, "open template")
	}

	templateBytes, err := ioutil.ReadFile(templatePath)
	if err != nil {
		return nil, errors.Wrapf(err, "read file")
	}

	return templateBytes, nil
}

// func (r *RuleSet) WriteToFile(filePath string, vars []string) error {
// 	fileObj, err := os.Create(filePath)
// 	if err != nil {
// 		return errors.Wrapf(err, "could not open file to write")
// 	}
// 	defer fileObj.Close()
//
// 	ruleData, err := r.GenerateRules(vars)
// 	if err != nil {
// 		return err
// 	}
//
// 	fileObj.Write(ruleData)
//
// 	return nil
// }
